<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solana RPC Connection</title>
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #1a1f2e;
            color: #ffffff;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #2a2f3e;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .status-panel {
            margin: 20px 0;
            padding: 15px;
            border-radius: 4px;
            background: #3a3f4e;
        }

        .endpoint {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            background: #4a4f5e;
        }

        .status-good {
            color: #4CAF50;
        }

        .status-warning {
            color: #FFC107;
        }

        .status-error {
            color: #F44336;
        }

        .loading {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        button {
            background: #5664d2;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }

        button:hover {
            background: #4254c2;
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        .metric-card {
            background: #3a3f4e;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }

        .metric-value {
            font-size: 24px;
            font-weight: bold;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Solana RPC Status Monitor</h1>
        <div id="statusPanel" class="status-panel">
            <h2>RPC Endpoints Status</h2>
            <div id="endpointStatus"></div>
        </div>
        <div class="metrics" id="metrics">
            <!-- Metrics will be populated here -->
        </div>
        <button onclick="checkAllEndpoints()">Refresh Status</button>
    </div>

    <script>
        // Configuration
        const RPC_ENDPOINTS = [
            {
                url: 'https://api.mainnet-beta.solana.com',
                name: 'Solana Mainnet (Primary)',
                headers: {
                    'Authorization': 'Bearer YOUR_API_KEY_HERE', // Replace with actual API key
                    'Content-Type': 'application/json'
                }
            },
            {
                url: 'https://solana-mainnet.g.alchemy.com/v2/demo',
                name: 'Alchemy (Fallback 1)',
                public: true
            },
            {
                url: 'https://solana.public-rpc.com',
                name: 'Public RPC (Fallback 2)',
                public: true
            },
            {
                url: 'https://api.mainnet.rpcpool.com',
                name: 'RPC Pool (Fallback 3)',
                public: true
            }
        ];

        class RPCMonitor {
            constructor(endpoints) {
                this.endpoints = endpoints;
                this.activeConnection = null;
            }

            async checkEndpoint(endpoint) {
                try {
                    const connection = new solanaWeb3.Connection(endpoint.url, {
                        commitment: 'confirmed',
                        confirmTransactionInitialTimeout: 10000,
                        fetch: async (url, options) => {
                            const fetchOptions = {
                                ...options,
                                headers: {
                                    ...options.headers,
                                    ...endpoint.headers
                                }
                            };
                            return fetch(url, fetchOptions);
                        }
                    });

                    const start = performance.now();
                    const blockHeight = await connection.getBlockHeight();
                    const latency = Math.round(performance.now() - start);

                    const health = await connection.getHealth();
                    const slotInfo = await connection.getSlot();

                    return {
                        status: 'ok',
                        blockHeight,
                        latency,
                        health,
                        slot: slotInfo,
                        connection
                    };
                } catch (error) {
                    console.error(`Error checking ${endpoint.name}:`, error);
                    return {
                        status: 'error',
                        error: error.message
                    };
                }
            }

            async checkAllEndpoints() {
                const statusDiv = document.getElementById('endpointStatus');
                const metricsDiv = document.getElementById('metrics');
                statusDiv.innerHTML = '';
                metricsDiv.innerHTML = '';

                for (const endpoint of this.endpoints) {
                    const endpointDiv = document.createElement('div');
                    endpointDiv.className = 'endpoint loading';
                    endpointDiv.innerHTML = `Checking ${endpoint.name}...`;
                    statusDiv.appendChild(endpointDiv);

                    const result = await this.checkEndpoint(endpoint);

                    if (result.status === 'ok') {
                        endpointDiv.className = 'endpoint status-good';
                        endpointDiv.innerHTML = `
                            ${endpoint.name}<br>
                            Status: Online<br>
                            Latency: ${result.latency}ms<br>
                            Block Height: ${result.blockHeight}<br>
                            Health: ${result.health}<br>
                            Current Slot: ${result.slot}
                        `;

                        // Update metrics
                        this.updateMetrics(result);

                        // Set as active connection if we don't have one
                        if (!this.activeConnection) {
                            this.activeConnection = result.connection;
                            console.log(`Set active connection to ${endpoint.name}`);
                        }
                    } else {
                        endpointDiv.className = 'endpoint status-error';
                        endpointDiv.innerHTML = `
                            ${endpoint.name}<br>
                            Status: Error<br>
                            Details: ${result.error}
                        `;
                    }
                }
            }

            updateMetrics(result) {
                const metricsDiv = document.getElementById('metrics');
                
                const metrics = [
                    { label: 'Block Height', value: result.blockHeight },
                    { label: 'Latency', value: `${result.latency}ms` },
                    { label: 'Current Slot', value: result.slot }
                ];

                metrics.forEach(metric => {
                    const metricCard = document.createElement('div');
                    metricCard.className = 'metric-card';
                    metricCard.innerHTML = `
                        <div>${metric.label}</div>
                        <div class="metric-value">${metric.value}</div>
                    `;
                    metricsDiv.appendChild(metricCard);
                });
            }

            getActiveConnection() {
                return this.activeConnection;
            }
        }

        // Initialize monitor
        const monitor = new RPCMonitor(RPC_ENDPOINTS);

        // Global function to check endpoints
        async function checkAllEndpoints() {
            await monitor.checkAllEndpoints();
        }

        // Initial check
        checkAllEndpoints();

        // Set up periodic checks
        setInterval(checkAllEndpoints, 30000); // Check every 30 seconds
    </script>
</body>
</html>
